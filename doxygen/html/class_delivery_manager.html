<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: DeliveryManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_delivery_manager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DeliveryManager Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_delivery_manager_8h_source.html">DeliveryManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_delivery_manager_1_1vert__struct.html">vert_struct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2a75ff1c37600302ec61f5b38e82a778" id="r_a2a75ff1c37600302ec61f5b38e82a778"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a75ff1c37600302ec61f5b38e82a778">DeliveryManager</a> (<a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::string</a> data_choice, <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::string</a> edge_choice)</td></tr>
<tr class="memdesc:a2a75ff1c37600302ec61f5b38e82a778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="class_delivery_manager.html">DeliveryManager</a> class.  <br /></td></tr>
<tr class="separator:a2a75ff1c37600302ec61f5b38e82a778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a0ff568850483ea9996e0fe33b5efa" id="r_a98a0ff568850483ea9996e0fe33b5efa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98a0ff568850483ea9996e0fe33b5efa">getDeliveryGraph</a> ()</td></tr>
<tr class="memdesc:a98a0ff568850483ea9996e0fe33b5efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the delivery graph.  <br /></td></tr>
<tr class="separator:a98a0ff568850483ea9996e0fe33b5efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2f556aed7fb05b839dbbcba4b9f7c0" id="r_a8e2f556aed7fb05b839dbbcba4b9f7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e2f556aed7fb05b839dbbcba4b9f7c0">backtracking</a> (<a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;<a class="el" href="class_edge.html">g</a>)</td></tr>
<tr class="memdesc:a8e2f556aed7fb05b839dbbcba4b9f7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the TSP using backtracking.  <br /></td></tr>
<tr class="separator:a8e2f556aed7fb05b839dbbcba4b9f7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcd6351a900535ccf54b7f1baee8b95" id="r_abbcd6351a900535ccf54b7f1baee8b95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbcd6351a900535ccf54b7f1baee8b95">backtrack_tsp</a> (<a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;<a class="el" href="class_edge.html">g</a>, <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">vis</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">v</a>, <a class="el" href="class_edge.html">double</a> &amp;<a class="el" href="class_edge.html">res</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">cost</a>)</td></tr>
<tr class="memdesc:abbcd6351a900535ccf54b7f1baee8b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backtracking function for solving the Traveling Salesman Problem (TSP).  <br /></td></tr>
<tr class="separator:abbcd6351a900535ccf54b7f1baee8b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e0aa66632e29bcfe1d5e18a45f0d33" id="r_a74e0aa66632e29bcfe1d5e18a45f0d33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74e0aa66632e29bcfe1d5e18a45f0d33">tsp2Approximation</a> (<a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;<a class="el" href="class_edge.html">g</a>)</td></tr>
<tr class="memdesc:a74e0aa66632e29bcfe1d5e18a45f0d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-Approximation algorithm for solving the Traveling Salesman Problem (TSP).  <br /></td></tr>
<tr class="separator:a74e0aa66632e29bcfe1d5e18a45f0d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7092bd6b733d06c9ee5426890165eb1e" id="r_a7092bd6b733d06c9ee5426890165eb1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7092bd6b733d06c9ee5426890165eb1e">mstPrim</a> (<a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;<a class="el" href="class_edge.html">g</a>, <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">start</a>)</td></tr>
<tr class="memdesc:a7092bd6b733d06c9ee5426890165eb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the Minimum Spanning Tree (MST) using Prim's algorithm.  <br /></td></tr>
<tr class="separator:a7092bd6b733d06c9ee5426890165eb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37519dfa5d98f311fc4149779cfbe25c" id="r_a37519dfa5d98f311fc4149779cfbe25c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37519dfa5d98f311fc4149779cfbe25c">dfsPrim</a> (<a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;<a class="el" href="class_edge.html">g</a>, <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">v</a>, <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;<a class="el" href="class_edge.html">res</a>, <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; <a class="el" href="class_edge.html">prim</a>)</td></tr>
<tr class="memdesc:a37519dfa5d98f311fc4149779cfbe25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-first search used in Prim's algorithm.  <br /></td></tr>
<tr class="separator:a37519dfa5d98f311fc4149779cfbe25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3139eb388ac4238eacb872ca25c644e" id="r_aa3139eb388ac4238eacb872ca25c644e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3139eb388ac4238eacb872ca25c644e">updateQueue</a> (<a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::priority_queue</a>&lt; <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;, <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &gt;, <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::greater</a>&lt; <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &gt; &gt; &amp;<a class="el" href="class_edge.html">V</a>, <a class="el" href="class_edge.html">double</a> <a class="el" href="class_edge.html">w</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *<a class="el" href="class_edge.html">v</a>)</td></tr>
<tr class="memdesc:aa3139eb388ac4238eacb872ca25c644e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the priority queue.  <br /></td></tr>
<tr class="separator:aa3139eb388ac4238eacb872ca25c644e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f6f474d9a95b79d3d2f3a983a51c5b" id="r_af7f6f474d9a95b79d3d2f3a983a51c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7f6f474d9a95b79d3d2f3a983a51c5b">findEdge</a> (<a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;<a class="el" href="class_edge.html">g</a>, <a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html">int</a> &amp;<a class="el" href="class_edge.html">in</a>, <a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html">int</a> &amp;dest)</td></tr>
<tr class="memdesc:af7f6f474d9a95b79d3d2f3a983a51c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge between two vertices.  <br /></td></tr>
<tr class="separator:af7f6f474d9a95b79d3d2f3a983a51c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcaf71c945bc552f1cca7676ff102e6" id="r_a7fcaf71c945bc552f1cca7676ff102e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fcaf71c945bc552f1cca7676ff102e6">findOddDegreeVertices</a> (<a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;<a class="el" href="class_edge.html">g</a>, <a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;<a class="el" href="class_edge.html">mst</a>)</td></tr>
<tr class="memdesc:a7fcaf71c945bc552f1cca7676ff102e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find odd degree vertices in a Minimum Spanning Tree (MST).  <br /></td></tr>
<tr class="separator:a7fcaf71c945bc552f1cca7676ff102e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3db81588d5ec2a563a88acb4674ef7" id="r_acc3db81588d5ec2a563a88acb4674ef7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *, <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc3db81588d5ec2a563a88acb4674ef7">minimumWeightPerfectMatching</a> (<a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">oddVertices</a>)</td></tr>
<tr class="memdesc:acc3db81588d5ec2a563a88acb4674ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the Minimum Weight Perfect Matching (MWPM) for odd degree vertices.  <br /></td></tr>
<tr class="separator:acc3db81588d5ec2a563a88acb4674ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb7c31d776777862d38e21cec217807" id="r_a9bb7c31d776777862d38e21cec217807"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bb7c31d776777862d38e21cec217807">combineMSTandMWPM</a> (<a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">mstEdges</a>, <a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">mwpmEdges</a>)</td></tr>
<tr class="memdesc:a9bb7c31d776777862d38e21cec217807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine MST edges and MWPM edges to form an Eulerian graph.  <br /></td></tr>
<tr class="separator:a9bb7c31d776777862d38e21cec217807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca156162b2253c64180ad2d332279712" id="r_aca156162b2253c64180ad2d332279712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca156162b2253c64180ad2d332279712">calculateTSPPath</a> (<a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;<a class="el" href="#aaec8df91da23bb48afa05ce157084644">eulerianCircuit</a>, <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;<a class="el" href="class_edge.html">g</a>, <a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">eulerianEdges</a>)</td></tr>
<tr class="memdesc:aca156162b2253c64180ad2d332279712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cost of a TSP path from an Eulerian circuit.  <br /></td></tr>
<tr class="separator:aca156162b2253c64180ad2d332279712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab702053edeeaeabf91fafbc093e33b51" id="r_ab702053edeeaeabf91fafbc093e33b51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab702053edeeaeabf91fafbc093e33b51">heuristicTSP</a> (<a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;<a class="el" href="class_edge.html">g</a>)</td></tr>
<tr class="memdesc:ab702053edeeaeabf91fafbc093e33b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heuristic approach to solve the Traveling Salesman Problem (TSP).  <br /></td></tr>
<tr class="separator:ab702053edeeaeabf91fafbc093e33b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec8df91da23bb48afa05ce157084644" id="r_aaec8df91da23bb48afa05ce157084644"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaec8df91da23bb48afa05ce157084644">eulerianCircuit</a> (<a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;<a class="el" href="class_edge.html">g</a>, <a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;<a class="el" href="class_edge.html">eulerianEdges</a>, <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">start</a>)</td></tr>
<tr class="memdesc:aaec8df91da23bb48afa05ce157084644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an Eulerian Circuit using Hierholzer's Algorithm.  <br /></td></tr>
<tr class="separator:aaec8df91da23bb48afa05ce157084644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7fdb55fc83d756c8ee5ab032dc0670" id="r_a1f7fdb55fc83d756c8ee5ab032dc0670"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f7fdb55fc83d756c8ee5ab032dc0670">realtsp</a> (<a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;<a class="el" href="class_edge.html">g</a>, <a class="el" href="class_edge.html">int</a> <a class="el" href="class_edge.html">v</a>)</td></tr>
<tr class="memdesc:a1f7fdb55fc83d756c8ee5ab032dc0670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact approach to solve the Traveling Salesman Problem (TSP).  <br /></td></tr>
<tr class="separator:a1f7fdb55fc83d756c8ee5ab032dc0670"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2a75ff1c37600302ec61f5b38e82a778" name="a2a75ff1c37600302ec61f5b38e82a778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a75ff1c37600302ec61f5b38e82a778">&#9670;&#160;</a></span>DeliveryManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DeliveryManager::DeliveryManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::string</a></td>          <td class="paramname"><span class="paramname"><em>vertex_file</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::string</a></td>          <td class="paramname"><span class="paramname"><em>edge_file</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for <a class="el" href="class_delivery_manager.html">DeliveryManager</a> class. </p>
<p>Initializes the delivery graph from the given vertex and edge files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_file</td><td>The file containing the vertex data. </td></tr>
    <tr><td class="paramname">edge_file</td><td>The file containing the edge data. If empty, the vertex file contains both vertices and edges. @complexity O(V + E) where V is the number of vertices and E is the number of edges. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abbcd6351a900535ccf54b7f1baee8b95" name="abbcd6351a900535ccf54b7f1baee8b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcd6351a900535ccf54b7f1baee8b95">&#9670;&#160;</a></span>backtrack_tsp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> DeliveryManager::backtrack_tsp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>vis</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>v</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>res</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>cost</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backtracking function for solving the Traveling Salesman Problem (TSP). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph. </td></tr>
    <tr><td class="paramname">vis</td><td>The number of visited vertices. </td></tr>
    <tr><td class="paramname">v</td><td>The current vertex. </td></tr>
    <tr><td class="paramname">res</td><td>The minimum cost result. </td></tr>
    <tr><td class="paramname">cost</td><td>The current cost. @complexity O(V!) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e2f556aed7fb05b839dbbcba4b9f7c0" name="a8e2f556aed7fb05b839dbbcba4b9f7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2f556aed7fb05b839dbbcba4b9f7c0">&#9670;&#160;</a></span>backtracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; DeliveryManager::backtracking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the TSP using backtracking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing the minimum cost and the time taken to find the solution. @complexity O(V!) </dd></dl>

</div>
</div>
<a id="aca156162b2253c64180ad2d332279712" name="aca156162b2253c64180ad2d332279712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca156162b2253c64180ad2d332279712">&#9670;&#160;</a></span>calculateTSPPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">double</a> DeliveryManager::calculateTSPPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>eulerianCircuit</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>eulerianEdges</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the cost of a TSP path from an Eulerian circuit. </p>
<p>This method removes repeated vertices to find a Hamiltonian circuit from the Eulerian circuit and calculates the total cost of the TSP path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eulerianCircuit</td><td>The Eulerian circuit. </td></tr>
    <tr><td class="paramname">g</td><td>The graph representing the delivery network. </td></tr>
    <tr><td class="paramname">eulerianEdges</td><td>The edges forming the Eulerian graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total cost of the TSP path. @complexity O(V + E) </dd></dl>

</div>
</div>
<a id="a9bb7c31d776777862d38e21cec217807" name="a9bb7c31d776777862d38e21cec217807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb7c31d776777862d38e21cec217807">&#9670;&#160;</a></span>combineMSTandMWPM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; DeliveryManager::combineMSTandMWPM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mstEdges</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mwpmEdges</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine MST edges and MWPM edges to form an Eulerian graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mstEdges</td><td>The edges of the Minimum Spanning Tree (MST). </td></tr>
    <tr><td class="paramname">mwpmEdges</td><td>The edges of the Minimum Weight Perfect Matching (MWPM). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of edges representing the Eulerian graph. @complexity O(V + E) </dd></dl>

</div>
</div>
<a id="a37519dfa5d98f311fc4149779cfbe25c" name="a37519dfa5d98f311fc4149779cfbe25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37519dfa5d98f311fc4149779cfbe25c">&#9670;&#160;</a></span>dfsPrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> DeliveryManager::dfsPrim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>v</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>res</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>prim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Depth-first search used in Prim's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph. </td></tr>
    <tr><td class="paramname">v</td><td>The current vertex. </td></tr>
    <tr><td class="paramname">res</td><td>The result vector. </td></tr>
    <tr><td class="paramname">prim</td><td>The MST predecessor vector. @complexity O(V + E) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaec8df91da23bb48afa05ce157084644" name="aaec8df91da23bb48afa05ce157084644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec8df91da23bb48afa05ce157084644">&#9670;&#160;</a></span>eulerianCircuit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; DeliveryManager::eulerianCircuit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>eulerianEdges</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>start</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an Eulerian Circuit using Hierholzer's Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph representing the delivery network. </td></tr>
    <tr><td class="paramname">eulerianEdges</td><td>The edges forming the Eulerian graph. </td></tr>
    <tr><td class="paramname">start</td><td>The starting vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector representing the Eulerian circuit. @complexity O(V + E) </dd></dl>

</div>
</div>
<a id="af7f6f474d9a95b79d3d2f3a983a51c5b" name="af7f6f474d9a95b79d3d2f3a983a51c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f6f474d9a95b79d3d2f3a983a51c5b">&#9670;&#160;</a></span>findEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * DeliveryManager::findEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html">int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html">int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the edge between two vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph. </td></tr>
    <tr><td class="paramname">in</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the edge, or nullptr if not found. @complexity O(E) </dd></dl>

</div>
</div>
<a id="a7fcaf71c945bc552f1cca7676ff102e6" name="a7fcaf71c945bc552f1cca7676ff102e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcaf71c945bc552f1cca7676ff102e6">&#9670;&#160;</a></span>findOddDegreeVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; DeliveryManager::findOddDegreeVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">const</a> <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mst</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find odd degree vertices in a Minimum Spanning Tree (MST). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph representing the delivery network. </td></tr>
    <tr><td class="paramname">mst</td><td>The predecessor list representing the MST. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vertices with odd degrees. @complexity O(V + E) </dd></dl>

</div>
</div>
<a id="a98a0ff568850483ea9996e0fe33b5efa" name="a98a0ff568850483ea9996e0fe33b5efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a0ff568850483ea9996e0fe33b5efa">&#9670;&#160;</a></span>getDeliveryGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp; DeliveryManager::getDeliveryGraph </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the delivery graph. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the unique pointer of the delivery graph. @complexity O(1) </dd></dl>

</div>
</div>
<a id="ab702053edeeaeabf91fafbc093e33b51" name="ab702053edeeaeabf91fafbc093e33b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab702053edeeaeabf91fafbc093e33b51">&#9670;&#160;</a></span>heuristicTSP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; DeliveryManager::heuristicTSP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Heuristic approach to solve the Traveling Salesman Problem (TSP). </p>
<p>This method first finds a Minimum Spanning Tree (MST), then finds the Minimum Weight Perfect Matching (MWPM) for odd degree vertices in the MST, and finally forms an Eulerian graph. An Eulerian circuit is found and converted to a TSP path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph representing the delivery network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing the total cost of the TSP path and the time taken to compute it. @complexity O(V^2 log V + V^3), where V is the number of vertices in the graph. </dd></dl>

</div>
</div>
<a id="acc3db81588d5ec2a563a88acb4674ef7" name="acc3db81588d5ec2a563a88acb4674ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3db81588d5ec2a563a88acb4674ef7">&#9670;&#160;</a></span>minimumWeightPerfectMatching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *, <a class="el" href="class_edge.html">Edge</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &gt; DeliveryManager::minimumWeightPerfectMatching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>oddVertices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the Minimum Weight Perfect Matching (MWPM) for odd degree vertices. </p>
<p>This naive approach finds the MWPM by checking each pair of vertices and choosing the minimum weight edge connecting them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oddVertices</td><td>The vertices with odd degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs representing the matched vertices and their connecting edges. @complexity O(V^2) </dd></dl>

</div>
</div>
<a id="a7092bd6b733d06c9ee5426890165eb1e" name="a7092bd6b733d06c9ee5426890165eb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7092bd6b733d06c9ee5426890165eb1e">&#9670;&#160;</a></span>mstPrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; DeliveryManager::mstPrim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>start</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the Minimum Spanning Tree (MST) using Prim's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph. </td></tr>
    <tr><td class="paramname">start</td><td>The starting vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of predecessors in the MST. @complexity O(E log V) </dd></dl>

</div>
</div>
<a id="a1f7fdb55fc83d756c8ee5ab032dc0670" name="a1f7fdb55fc83d756c8ee5ab032dc0670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7fdb55fc83d756c8ee5ab032dc0670">&#9670;&#160;</a></span>realtsp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; DeliveryManager::realtsp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">int</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exact approach to solve the Traveling Salesman Problem (TSP). </p>
<p>This method uses a similar approach as heuristicTSP but starts from a specified starting vertex. It finds an MST, then finds the MWPM for odd degree vertices in the MST, and finally forms an Eulerian graph. An Eulerian circuit is found and converted to a TSP path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph representing the delivery network. </td></tr>
    <tr><td class="paramname">s</td><td>The starting vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing the total cost of the TSP path and the time taken to compute it. @complexity O(V^2 log V + V^3), where V is the number of vertices in the graph. </dd></dl>

</div>
</div>
<a id="a74e0aa66632e29bcfe1d5e18a45f0d33" name="a74e0aa66632e29bcfe1d5e18a45f0d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e0aa66632e29bcfe1d5e18a45f0d33">&#9670;&#160;</a></span>tsp2Approximation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_edge.html">double</a> &gt; DeliveryManager::tsp2Approximation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::unique_ptr</a>&lt; <a class="el" href="class_graph.html">Graph</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-Approximation algorithm for solving the Traveling Salesman Problem (TSP). </p>
<p>This method uses a Minimum Spanning Tree (MST) followed by a depth-first search (DFS) to find a Hamiltonian circuit that approximates the TSP tour within a factor of 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The graph representing the delivery network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing the total cost of the approximate TSP tour and the time taken to compute it. @complexity O(V^2 log V) </dd></dl>

</div>
</div>
<a id="aa3139eb388ac4238eacb872ca25c644e" name="aa3139eb388ac4238eacb872ca25c644e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3139eb388ac4238eacb872ca25c644e">&#9670;&#160;</a></span>updateQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_edge.html">void</a> DeliveryManager::updateQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::priority_queue</a>&lt; <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt;, <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::vector</a>&lt; <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &gt;, <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::greater</a>&lt; <a class="el" href="class_edge.html#ab976213419283ed754f42f57b195a288">std::pair</a>&lt; <a class="el" href="class_edge.html">double</a>, <a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; * &gt; &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_edge.html">double</a></td>          <td class="paramname"><span class="paramname"><em>w</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a>&lt; <a class="el" href="class_edge.html">int</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the priority queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>The priority queue. </td></tr>
    <tr><td class="paramname">w</td><td>The weight. </td></tr>
    <tr><td class="paramname">v</td><td>The vertex. @complexity O(V) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/jlsmp/Downloads/DA_project2-master/DA_project2-master/<a class="el" href="_delivery_manager_8h_source.html">DeliveryManager.h</a></li>
<li>C:/Users/jlsmp/Downloads/DA_project2-master/DA_project2-master/<a class="el" href="_delivery_manager_8cpp.html">DeliveryManager.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
